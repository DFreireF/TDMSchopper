{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TDMSchopper Script Documentation","text":"<p>This documentation provides an overview of the TDMSchopper script functionality.</p> <p>The TDMSchopper script processes input arguments from the command line to specify the duration of the analysis, the starting point of the analysis, and the number of frequency bins. It then calls the <code>controller()</code> function, which coordinates the chopping and stacking process. The <code>controller()</code> function uses methods from the <code>TDMSchopper.model</code> module to retrieve necessary data files, analyze the data, and save the chopped and stacked data in a NumPy file called <code>zz_cutted_and_stacked.npz</code>.</p>"},{"location":"#main","title":"main()","text":"<p>Main entry point of the TDMSchopper script.</p> <p>This function parses command-line arguments, performs the chopping and stacking of data, and saves the result in a NumPy file.</p>"},{"location":"#command-line-arguments","title":"Command-line Arguments:","text":"<ul> <li> <p><code>-t</code>, <code>--time</code> : float, optional (default=1)   The duration in seconds of data to analyze, starting from an offset in time (skip).</p> </li> <li> <p><code>-s</code>, <code>--skip</code> : float, optional (default=10)   The starting point in time of the analysis, measured in seconds from the injection time.</p> </li> <li> <p><code>-b</code>, <code>--binning</code> : int, optional (default=2**21)   The number of frequency bins (lframes) used during the analysis.</p> </li> </ul>"},{"location":"#returns","title":"Returns:","text":"<p>None</p>"},{"location":"#controllerlframes-time-skip","title":"controller(lframes, time, skip)","text":"<p>Controller function responsible for orchestrating the data chopping and stacking process.</p> <p>This function retrieves relevant data files, analyzes data based on provided time and skip parameters, and saves the resulting chopped and stacked data in a NumPy file.</p>"},{"location":"#parameters","title":"Parameters:","text":"<ul> <li> <p><code>lframes</code> : int   Number of frequency bins (lframes) used during the analysis.</p> </li> <li> <p><code>time</code> : float   The duration in seconds of data to analyze, starting from an offset in time (skip).</p> </li> <li> <p><code>skip</code> : float   The starting point in time of the analysis, measured in seconds from the injection time.</p> </li> </ul>"},{"location":"#returns_1","title":"Returns:","text":"<p>None</p>"},{"location":"model/","title":"model.py Documentation","text":"<p>This documentation provides an overview of the functions implemented in the <code>model.py</code> module of the TDMSchopper project.</p>"},{"location":"model/#analyserfile2datetime64file","title":"analyserfile2datetime64(file)","text":"<p>Convert an analyser file name to a <code>numpy.datetime64</code> object.</p>"},{"location":"model/#parameters","title":"Parameters:","text":"<ul> <li><code>file</code> : str   The file name to convert.</li> </ul>"},{"location":"model/#returns","title":"Returns:","text":"<p><code>numpy.datetime64</code>   The corresponding <code>numpy.datetime64</code> object.</p>"},{"location":"model/#kicker_timesfilename-channel4-fs99999","title":"kicker_times(filename, channel=4, fs=999.99)","text":"<p>Extract kicker times from a TDMS file.</p>"},{"location":"model/#parameters_1","title":"Parameters:","text":"<ul> <li> <p><code>filename</code> : str   The TDMS file name.</p> </li> <li> <p><code>channel</code> : int, optional (default=4)   The channel number containing the kicker data.</p> </li> <li> <p><code>fs</code> : float, optional (default=999.99)   The sampling frequency in Hz.</p> </li> </ul>"},{"location":"model/#returns_1","title":"Returns:","text":"<p><code>list</code>   A list of kicker times as <code>numpy.datetime64</code> objects.</p>"},{"location":"model/#convert_date_to_filenamedate","title":"convert_date_to_filename(date)","text":"<p>Convert a <code>numpy.datetime64</code> object to a formatted file name.</p>"},{"location":"model/#parameters_2","title":"Parameters:","text":"<ul> <li><code>date</code> : <code>numpy.datetime64</code>   The date to convert.</li> </ul>"},{"location":"model/#returns_2","title":"Returns:","text":"<p><code>str</code>   The formatted file name corresponding to the input date.</p>"},{"location":"model/#datetime642analyserfiledatetime64-head","title":"datetime642analyserfile(datetime64, head='')","text":"<p>Convert a <code>numpy.datetime64</code> object to an analyser file name.</p>"},{"location":"model/#parameters_3","title":"Parameters:","text":"<ul> <li> <p><code>datetime64</code> : <code>numpy.datetime64</code>   The date to convert.</p> </li> <li> <p><code>head</code> : str, optional (default='')   The additional head (prefix) to be added to the file name.</p> </li> </ul>"},{"location":"model/#returns_3","title":"Returns:","text":"<p><code>str</code>   The analyser file name corresponding to the input date.</p>"},{"location":"model/#get_analyser_fileshead-termination","title":"get_analyser_files(head, termination)","text":"<p>Get a sorted list of analyser files in the specified directory.</p>"},{"location":"model/#parameters_4","title":"Parameters:","text":"<ul> <li> <p><code>head</code> : str   The directory containing the analyser files.</p> </li> <li> <p><code>termination</code> : str   The file extension or termination of the analyser files.</p> </li> </ul>"},{"location":"model/#returns_4","title":"Returns:","text":"<p><code>numpy.ndarray</code>   A sorted array of analyser file names.</p>"},{"location":"model/#get_time_delta_between_filesanalyser_files","title":"get_time_delta_between_files(analyser_files)","text":"<p>Calculate the time differences between consecutive analyser files.</p>"},{"location":"model/#parameters_5","title":"Parameters:","text":"<ul> <li><code>analyser_files</code> : <code>numpy.ndarray</code>   A sorted array of analyser file names.</li> </ul>"},{"location":"model/#returns_5","title":"Returns:","text":"<p><code>numpy.ndarray</code>   An array of time differences in seconds between consecutive analyser files.</p>"},{"location":"model/#plot_in_subsetsarrayx-arrayy-n_subsets","title":"plot_in_subsets(arrayx, arrayy, n_subsets)","text":"<p>Plot data in subsets.</p>"},{"location":"model/#parameters_6","title":"Parameters:","text":"<ul> <li> <p><code>arrayx</code> : <code>numpy.ndarray</code>   The x-axis data array.</p> </li> <li> <p><code>arrayy</code> : <code>numpy.ndarray</code>   The y-axis data array.</p> </li> <li> <p><code>n_subsets</code> : int   The number of subsets to plot.</p> </li> </ul>"},{"location":"model/#returns_6","title":"Returns:","text":"<p>None</p>"},{"location":"model/#find_key_in_rangedictionary-value","title":"find_key_in_range(dictionary, value)","text":"<p>Find a key in a dictionary based on a value within a range.</p>"},{"location":"model/#parameters_7","title":"Parameters:","text":"<ul> <li> <p><code>dictionary</code> : dict   The dictionary to search in.</p> </li> <li> <p><code>value</code> : <code>numpy.datetime64</code>   The value to find within the ranges of the dictionary values.</p> </li> </ul>"},{"location":"model/#returns_7","title":"Returns:","text":"<p>object or None   The key corresponding to the matching value, or None if no match is found.</p>"},{"location":"model/#create_dictionaryfilenames-values1-values2","title":"create_dictionary(filenames, values1, values2)","text":"<p>Create a dictionary using the given arrays as keys and values.</p>"},{"location":"model/#parameters_8","title":"Parameters:","text":"<ul> <li> <p><code>filenames</code> : <code>numpy.ndarray</code>   The keys for the dictionary.</p> </li> <li> <p><code>values1</code> : <code>numpy.ndarray</code>   The first values for the dictionary.</p> </li> <li> <p><code>values2</code> : <code>numpy.ndarray</code>   The second values for the dictionary.</p> </li> </ul>"},{"location":"model/#returns_8","title":"Returns:","text":"<p><code>dict</code>   The created dictionary.</p>"},{"location":"model/#initial_final_timestampsfile-referencenpdatetime642021-06-30t232734000000-correctionnptimedelta641280157120-ns","title":"initial_final_timestamps(file, reference=np.datetime64('2021-06-30T23:27:34.000000'), correction=np.timedelta64(1280157120, 'ns'))","text":"<p>Get the initial and final timestamps of a TDMS file.</p>"},{"location":"model/#parameters_9","title":"Parameters:","text":"<ul> <li> <p><code>file</code> : str   The TDMS file name.</p> </li> <li> <p><code>reference</code> : <code>numpy.datetime64</code>, optional (default=np.datetime64('2021-06-30T23:27:34.000000'))   The reference timestamp for corrections.</p> </li> <li> <p><code>correction</code> : <code>numpy.timedelta64</code>, optional (default=np.timedelta64(1280157120, 'ns'))   The correction value in nanoseconds.</p> </li> </ul>"},{"location":"model/#returns_9","title":"Returns:","text":"<p><code>tuple</code>   A tuple containing the initial and final timestamps as <code>numpy.datetime64</code> objects.</p>"},{"location":"model/#get_sc_filesheadlustreaplitv-exp2021-07-03_e143_twophotondecay_ssanjarintcapscsc_2021-06-30_23-27-45","title":"get_sc_files(head='/lustre/ap/litv-exp/2021-07-03_E143_TwoPhotonDecay_ssanjari/ntcap/sc/SC_2021-06-30_23-27-45/')","text":"<p>Get a list of SC files.</p>"},{"location":"model/#parameters_10","title":"Parameters:","text":"<ul> <li><code>head</code> : str, optional (default='/lustre/ap/litv-exp/2021-07-03_E143_TwoPhotonDecay_ssanjari/ntcap/sc/SC_2021-06-30_23-27-45/')   The directory containing the SC files.</li> </ul>"},{"location":"model/#returns_10","title":"Returns:","text":"<p><code>list</code>   A list of SC file names.</p>"},{"location":"model/#get_iq_filesheadlustreaplitv-exp2021-07-03_e143_twophotondecay_ssanjarintcapiqiq_2021-06-30_23-27-34_part3","title":"get_iq_files(head='/lustre/ap/litv-exp/2021-07-03_E143_TwoPhotonDecay_ssanjari/ntcap/iq/IQ_2021-06-30_23-27-34_part3/')","text":"<p>Get a list of IQ files.</p>"},{"location":"model/#parameters_11","title":"Parameters:","text":"<ul> <li><code>head</code> : str, optional (default='/lustre/ap/litv-exp/2021-07-03_E143_TwoPhotonDecay_ssanjari/ntcap/iq/IQ_2021-06-30_23-27-34_part3/')   The directory containing the IQ files.</li> </ul>"},{"location":"model/#returns_11","title":"Returns:","text":"<p><code>list</code>   A list of IQ file names.</p>"},{"location":"model/#get_kick_timesc_files","title":"get_kick_time(sc_files)","text":"<p>Get kicker times from a list of SC files.</p>"},{"location":"model/#parameters_12","title":"Parameters:","text":"<ul> <li><code>sc_files</code> : list   A list of SC file names.</li> </ul>"},{"location":"model/#returns_12","title":"Returns:","text":"<p><code>numpy.ndarray</code>   An array of kicker times as <code>numpy.datetime64</code> objects.</p>"},{"location":"model/#get_absolute_time_file_rangesiq_files","title":"get_absolute_time_file_ranges(iq_files)","text":"<p>Get absolute time ranges for IQ files.</p>"},{"location":"model/#parameters_13","title":"Parameters:","text":"<ul> <li><code>iq_files</code> : list   A list of IQ file names.</li> </ul>"},{"location":"model/#returns_13","title":"Returns:","text":"<p><code>dict</code>   A dictionary containing IQ file names as keys and their corresponding time ranges (start, finish) as values (<code>numpy.datetime64</code> objects).</p>"},{"location":"model/#chop_and_stacklframes221-time1-fs20000000-offset_in_seconds_from_injection10-kick_timenone-file_rangesnone","title":"chop_and_stack(lframes=2**21, time=1, fs=20000000, offset_in_seconds_from_injection=10, kick_time=None, file_ranges=None)","text":"<p>Chop and stack IQ data based on injection times.</p>"},{"location":"model/#parameters_14","title":"Parameters:","text":"<ul> <li> <p><code>lframes</code> : int, optional (default=2**21)   Number of frequency bins (lframes) used during the analysis.</p> </li> <li> <p><code>time</code> : float, optional (default=1)   The duration in seconds of data to analyze, starting from an offset in time (skip).</p> </li> <li> <p><code>fs</code> : int, optional (default=20000000)   The sampling frequency in Hz.</p> </li> <li> <p><code>offset_in_seconds_from_injection</code> : float, optional (default=10)   The starting point in time of the analysis, measured in seconds from the injection time.</p> </li> <li> <p><code>kick_time</code> : <code>numpy.ndarray</code>, optional (default=None)   An array of kicker times as <code>numpy.datetime64</code> objects.</p> </li> <li> <p><code>file_ranges</code> : <code>dict</code>, optional (default=None)   A dictionary containing IQ file names as keys and their corresponding time ranges (start, finish) as values (<code>numpy.datetime64</code> objects).</p> </li> </ul>"},{"location":"model/#returns_14","title":"Returns:","text":"<p><code>numpy.ndarray</code>   A 2D array containing the chopped and stacked data (<code>zz_sum</code>).</p>"}]}